# GitHub Copilot Instructions

This document provides a set of rules and guidelines for GitHub Copilot to follow when assisting with development tasks in this repository. The goal is to ensure that Copilot's actions are safe, predictable, and helpful.

---

## 1. Interacting with Terminal Commands

- **Anticipate Interactivity**: When using `run_in_terminal`, be aware that some CLI commands are interactive and will require user input (e.g., `npm init`, `nest generate resource`). If a command prompts for input, present it to the user and ask for the necessary information before proceeding.
- **Background Tasks**: For long-running processes like development servers or watch scripts, use the `isBackground: true` option in `run_in_terminal` and inform the user that the task is running in the background.

---

## 2. Asking Clarifying Questions

- **Seek Clarity**: If a request is ambiguous, or if a command requires parameters that have not been provided, ask the user for clarification.
- **Provide Options**: When asking for clarification, provide a list of options whenever possible to make it easier for the user to respond. If a tool is available to ask follow-up questions with options, prefer using it.
- **No Assumptions**: Do not make assumptions about implementation details, command parameters (e.g., `--no-spec`), or desired outcomes.

---

## 3. Verification & Error Handling

- **Verify All Actions**: After running a command or editing a file, verify that the action was successful and produced the expected outcome.
  - For terminal commands, inspect the exit code and output
  - For file edits, use `read_file` to confirm changes were applied correctly
  - Use `get_errors` to check for any new errors or warnings introduced by your changes
- **Report Failures**: If a tool call fails or a command returns an error, report the failure to the user, explain what went wrong, and ask how to proceed.
- **Respect any changes were made. Do not retry the operation unless the user asks you to.

---

## 4. Using Git Tools

- **Absolute Paths**: When using git-related tools, always provide the absolute path to the repository.
- **Confirm Destructive Actions**: Never push changes to a remote repository or perform potentially destructive actions (e.g., `git reset --hard`, force-pushing) without explicit confirmation from the user.

---

## 5. Code Formatting and Linting

- **Respect Project Style**: Adhere to the existing coding style and conventions of the project.
- **Use Project Linters**: Apply project-configured linters or formatters (Biome, ESLint, Prettier, etc.) after making changes. If no configuration exists, use `biome check --fix {path}`.
- **Fix Issues**: Run linter/formatter before changes are considered complete to catch any auto-fixable issues.
- **DO NOT** add comments that repeat what the code already clearly expresses. These "noise comments" add no value and clutter the codebase.

### Bad Examples
```typescript
// Group ID format: [a-zA-Z]@[a-zA-Z0-9_-]  ← Redundant: regex shows this
export const GroupIdSchema = z.string().regex(/^[a-zA-Z]@[a-zA-Z0-9_-]+$/);
```

## 6. Using the Memory Bank

The memory bank (`/.github/copilot/Memory-Bank/`) is the **single source of truth** for architectural decisions, patterns, and constraints. Always consult it before making assumptions.

### 6.0 Memory Bank Frontmatters Are Auto-Loaded

Frontmatters from all memory bank files are **automatically loaded at the start of every task**. This provides the "index" of all architectural knowledge immediately.

If you didn't receive this, then real all frontmatters using `head -n 10 .github/copilot/Memory-Bank/**/*.md`

**Your approach:**

1. **Scan the loaded frontmatters** for relevance using metadata:
   - `purpose:` - What this file documents
   - `triggers:` - When to consult it
   - `keywords:` - Search terms
   - `dependencies:` - Related files to check
   - `status:` - active, archived, or deprecated
   - First sentence - Quick summary

2. **Lazily load full files** only if frontmatter indicates relevance to your task

3. **Never assume** architecture, patterns, or decisions without consulting memory first

This maximizes context efficiency: you work with the "index" of knowledge immediately available, then drill into specifics as needed.

### 6.1 How to Use the Memory Bank

**Your workflow:**

1. **Read the README** (`Memory-Bank/README.md`) to find your task category and recommended files
2. **Scan loaded frontmatters** for relevance using metadata (purpose, triggers, keywords, dependencies)
3. **Lazily load full files** only when frontmatter indicates relevance to your task
4. **Never assume** architecture, patterns, or decisions without consulting memory first

### 6.2 Common Patterns (Copy From Memory Bank)

**Never write patterns from scratch.** Reference and adapt from:

- tRPC procedure: `implementation/01-trpc-procedures.md` (has real example code)
- Service class: `implementation/00-service-layer.md` (has template with DI)
- Auth guard: `implementation/03-auth-guards.md` (has validation code)
- Domain structure: `implementation/04-domain-structure.md` (file organization)

**Process before writing code:**
1. Define task
2. Consult memory bank (README → relevant files)
3. Find pattern/rule/example
4. Stop and rephrase user request in clear format to enhance clarity for both coding agents and human readers. This ensures the request is unambiguous, actionable, and aligned with best practices for coding tasks.
5. Write code based on pattern
6. Check gotchas for mistakes
7. Run rules checklist before PR

---

## 7. Saving Agent Memory (All Tools)

Even if you're using Copilot, Claude Code, Cursor, Gemini CLI, or another AI agent, **you MUST persist learnings between sessions** by updating memory bank files.

### When to Save Memory

Update the memory bank immediately if:
- ✅ You learned new architectural patterns or conventions
- ✅ You received user feedback or corrections
- ✅ You discovered antipatterns or "smells"
- ✅ You solved a complex problem with reusable patterns
- ✅ You clarified ambiguous requirements

### Memory Update Checklist

Before updating memory, verify:
- ✅ Changes are documented clearly with examples
- ✅ Cross-references to related files are included
- ✅ Frontmatter metadata is updated
- ✅ Status and timestamps are current

### Correcting Memory Immediately

If the user corrects you about architecture, scope, or documented patterns:
1. ✅ Acknowledge the correction immediately
2. ✅ Update relevant memory bank files right away (don't wait for session end)
3. ✅ Update all cross-references and frontmatter `updated:` timestamp

This ensures all future agents get accurate information.

---

## 8. Agent Workflow & Memory Updates

### When to Update Memory

**IMMEDIATELY after implementing a feature and all tests pass:**

1. **✅ Feature Implementation Complete**
   - Code is written and working
   - All tests pass (`npm test` or equivalent)
   - No linting errors
   - Feature is ready for PR

2. **✅ Update Memory Bank**
   - Add new patterns to `implementation/` files
   - Document gotchas in `gotchas/` files  
   - Update examples in existing files
   - Add cross-references between related files

3. **✅ Update Frontmatters**
   - Add new `keywords:` for discoverability
   - Update `updated:` timestamp
   - Add new `triggers:` if applicable
   - Update `dependencies:` if new relationships exist

**Why update immediately?**
- **Memory updates are NOT a side task** - they are as or more important than the user task itself
- **Future agents get accurate information** - prevents repeating mistakes
- **Knowledge compounds** - each implementation builds on previous ones
- **Prevents drift** - keeps documentation in sync with code
- **Enables consistency** - all agents follow the same patterns

### Memory Update Checklist

Before submitting PR with new feature:
- [ ] All tests pass
- [ ] Memory bank updated with new patterns
- [ ] Examples in memory bank match implementation
- [ ] Frontmatters updated with new keywords/triggers
- [ ] Cross-references added to related files

---

## 9. Task Planning and Progress

- **Use Todo List**: Use the task/todo list tool to create and manage a todo list for the current task.
- **Track Progress**: Use the following states to track progress: `not-started`, `in-progress`, and `completed`.
