datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

generator client {
  provider = "prisma-client-js"
}

model User {
  // -- unique identifiers --
  internalId String @id @default(cuid())
  humanId    String @unique //TODO: add history so later someone else cannot use the same humanId
  email      String @unique
  authSchId  String @unique

  // -- non-unique identifiers --
  firstName              String
  lastName               String
  nickname               String
  isArchived             Boolean
  cellPhone              String
  homeAddress            String
  dateOfBirth            DateTime               @db.Date()
  room                   String
  dormitory              Dormitory              @default(UNKNOWN)
  gender                 Gender                 @default(UNKNOWN)
  studentStatus          StudentStatus          @default(UNKNOWN)
  createdAt              DateTime?              @default(now())
  lastLogin              DateTime?
  memberships            Membership[]
  roles                  RoleOnUser[]
  reviewedScoreboards    Scoreboard[]
  entryAwardRequests     EntryAwardRequest[]
  pointAwardRequests     PointAwardRequest[]
  pointAwardHistories    PointAwardHistory[]
  externalAccounts       ExternalAccountLink[]
  sensitiveInfoPrivacies SensitiveInfoPrivacy[]
}

enum Dormitory {
  KARMAN
  TETENY
  SCH
  BAROSS
  BERCSENYI
  VASARHELYI
  EXTERNAL
  UNKNOWN
}

enum Gender {
  MALE
  FEMALE
  OTHER
  UNKNOWN
}

enum StudentStatus {
  ACTIVE
  GRADUATED
  OTHER
  UNKNOWN
}

model ExternalAccountLink {
  id          String @id @default(cuid())
  protocol    String
  accountName String
  ownerId     String
  owner       User   @relation(fields: [ownerId], references: [internalId])
}

/// * User can control which profile attrs are sensitive for public display
model SensitiveInfoPrivacy {
  id            String                 @id @default(cuid())
  attributeName SensitiveInfoAttribute
  visible       Boolean                @default(false)
  ownerId       String
  owner         User                   @relation(fields: [ownerId], references: [internalId])
}

/// * List of attributes that can be hidden from public view
/// * @memberof {SensitiveInfoPrivacy}
enum SensitiveInfoAttribute {
  CELL_PHONE
  EMAIL
  WEBPAGE
  ROOM_NUMBER
  GENDER
  HOME_ADDRESS
  DATE_OF_BIRTH
}

model Group {
  id                      String           @id @default(cuid())
  name                    String
  description             String
  parent                  Group?           @relation("ParentGroup", fields: [parentId], references: [id])
  parentId                String?
  children                Group[]          @relation("ParentGroup")
  isCommunity             Boolean // kor-e
  isResort                Boolean // reszort-e
  isTaskForce             Boolean // task force-e
  hasTransitiveMembership Boolean // osszeszedi-e az alatta levo csoportok tagjait
  isArchived              Boolean
  purpose                 GroupPurpose
  memberships             Membership[]
  awardGuideLines         AwardGuideline[]
  // derived avaiableFlares String[]
  policies                Policy[]

  Scoreboard               Scoreboard[]
  AwardGuideLineCollection AwardGuideLineCollection[]
  Role                     Role[]
}

/// * @memberof {Group}
enum GroupPurpose {
  UNKNOWN
  OLD // @map("old")
  COMMITTEE // @map("bizottság")
  PARTY // @map("bulis")
  CIRCLE // @map("csoport")
  D // @map("D")
  ELLIPSE // @map("ellipszis")
  A_CLASS // @map("évfolyam")
  GROUP // @map("Kor")
  CULTURE // @map("kultur")
  PROJECT // @map("projekt")
  EVENT // @map("rendezveny")
  RESORT // @map("reszort")
  SPORT1 // @map("sport")
  PROFESSIONAL // @map("szakmai kör")
  FLOOR // @map("szint")
  SERVICE // @map("szolgáltató kör")
}

model Membership {
  id               String             @id @default(cuid())
  user             User               @relation(fields: [userId], references: [internalId])
  userId           String
  group            Group              @relation(fields: [groupId], references: [id])
  groupId          String
  isArchived       Boolean
  flairs           String[]
  membershipStatus MembershipStatus[]
}

model MembershipStatus {
  id           String     @id @default(cuid())
  membershipId String
  membership   Membership @relation(fields: [membershipId], references: [id])
  status       String
  createdAt    DateTime   @default(now())
  endedAt      DateTime?
}

model AwardGuideLineCollection {
  id        String   @id @default(cuid())
  createdAt DateTime @default(now())
  group     Group    @relation(fields: [groupId], references: [id])
  groupId   String

  Scoreboard     Scoreboard[]
  AwardGuideline AwardGuideline[]
}

model AwardGuideline {
  id                         String                   @id @default(cuid())
  name                       String // 0 times NULL, Should frontend list these values?
  description                String
  postCategory               PostCategory
  maxPerMember               Int
  maxPerGuideline            Int
  awardGuideLineCollection   AwardGuideLineCollection @relation(fields: [awardGuideLineCollectionId], references: [id])
  awardGuideLineCollectionId String

  Scoreboard        Scoreboard[]
  Group             Group?              @relation(fields: [groupId], references: [id])
  groupId           String?
  PointAwardRequest PointAwardRequest[]
}

/// * @memberof {AwardGuideline}
enum PostCategory {
  WORK
  RESPONSIBILITY
}

enum EvaluationStatus {
  NOT_SUBMITTED
  NOT_YET_REVIEWED
  ACCEPTED
  REJECTED
}

model Scoreboard {
  id                         String                   @id @default(cuid())
  entryRequestsStatus        EvaluationStatus         @default(NOT_SUBMITTED)
  pointRequestsStatus        EvaluationStatus         @default(NOT_SUBMITTED)
  createdAt                  DateTime?                @default(now())
  scoringSeasonId            String
  justification              String // koros beszamolo
  lastEvaulation             DateTime?                @map("last_evaulation") @db.Timestamp(6) // 50% is NULL
  lastModification           DateTime?                @map("last_modification") @db.Timestamp(6)
  reviewerUserId             String?
  groupId                    String
  group                      Group                    @relation(fields: [groupId], references: [id])
  nextScoreboardId           String?
  nextScoreboard             Scoreboard?              @relation("evaluationsToevaluations", fields: [nextScoreboardId], references: [id])
  thePrevVersion             Scoreboard[]             @relation("evaluationsToevaluations")
  /// When RVT members change the status of the report, they can leave a message here.
  /// The message is also added as {EvaluationMessage}
  reportEvaluationMessage    String?                  @map("explanation") // 70% is NULL
  isConsidered               Boolean                  @default(false) @map("is_considered")
  reviewer                   User?                    @relation(fields: [reviewerUserId], references: [internalId])
  principles                 AwardGuideline[]
  awardGuideLineCollection   AwardGuideLineCollection @relation(fields: [awardGuideLineCollectionId], references: [id])
  awardGuideLineCollectionId String

  pointAwardRequests PointAwardRequest[]
  entryAwardRequests EntryAwardRequest[]
  PointAwardHistory  PointAwardHistory[]
}

model EntryAwardRequest {
  id            String         @id @default(cuid())
  award         EntryAwardType @default(KULSOS_DO) @map("entry_type")
  justification String // 185 NULL and 100000 empty string, group leader can explain the work of the awardee
  scoreboardId  String         @map("evaluation_id")
  awardeeId     String         @map("user_id")
  //could be Membership
  awardee       User           @relation(fields: [awardeeId], references: [internalId])
  scoreboard    Scoreboard     @relation(fields: [scoreboardId], references: [id])

  @@unique([awardeeId, scoreboardId])
}

/// * https://vik.wiki/GYIK_-_Sch%C3%B6nherz#K.C3.B6z.C3.A9let
enum EntryAwardType {
  KULSOS_DO         @map("KDO")
  KOLLEGIUMI_BELEPO @map("KB")
  ALLANDO_BELEPO    @map("AB")
}

model PointAwardRequest {
  id           String         @id @default(cuid())
  point        Int
  scoreboardId String         @map("evaluation_id")
  awardeeId    String         @map("user_id")
  guidelineId  String
  guideline    AwardGuideline @relation(fields: [guidelineId], references: [id])
  explanations Json
  scoreboard   Scoreboard     @relation(fields: [scoreboardId], references: [id])
  awardee      User           @relation(fields: [awardeeId], references: [internalId])

  @@unique([scoreboardId, awardeeId])
}

model PointAwardHistory {
  id           String     @id @default(cuid())
  awardeeId    String
  point        Int
  awarded      User       @relation(fields: [awardeeId], references: [internalId])
  scoreboard   Scoreboard @relation(fields: [scoreboardId], references: [id])
  scoreboardId String
  // TODO: calculate point automatically

  @@unique([awardeeId, scoreboardId])
  @@map("point_histories")
}

model Permission {
  id         String           @id @default(cuid())
  action     PermissionAction
  resourceId String
  policy     Policy           @relation(fields: [policyId], references: [id])
  policyId   String
}

enum PermissionAction {
  CREATE
  READ
  UPDATE
  DELETE
}

model Policy {
  id          String         @id @default(cuid())
  groupId     String
  group       Group          @relation(fields: [groupId], references: [id])
  name        String
  createdAt   DateTime       @default(now())
  updatedAt   DateTime       @updatedAt
  permissions Permission[]
  roles       RoleOnPolicy[]
}

model Role {
  id          String         @id @default(cuid())
  name        String
  description String
  group       Group          @relation(fields: [groupId], references: [id])
  groupId     String
  policies    RoleOnPolicy[]
  users       RoleOnUser[]
}

model RoleOnPolicy {
  role     Role   @relation(fields: [roleId], references: [id])
  roleId   String
  policy   Policy @relation(fields: [policyId], references: [id])
  policyId String

  @@id([roleId, policyId])
}

model RoleOnUser {
  role   Role   @relation(fields: [roleId], references: [id])
  roleId String
  user   User   @relation(fields: [userId], references: [internalId])
  userId String

  @@id([userId, roleId])
}
